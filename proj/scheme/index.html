<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="description" content ="CS61A: Structure and Interpretation of Computer Programs" />
    <meta name="keywords" content ="CS61A, Computer Science, CS, 61A, Programming, John DeNero, Berkeley, EECS" />
    <meta name="author" content ="Albert Wu, Robert Huang, Alfonso Martinez, Cale Horeff, Chris Le, Colin Schoen, Derrick Lin, Jeffrey Lu, Jessica Gu, Rohit Lalchandani, Tammy Nguyen, Will Jiang, Yulin Zheng" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width">

    <script src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>
    <script src="/assets/js/bootstrap.min.js"></script>

    <link rel="stylesheet" href="/assets/css/bootstrap.min.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/style.css">
    <link rel="icon" href="/assets/images/favicon.ico">

    <link rel="stylesheet" href="/assets/css/mono-blue.css">
    <script src="/assets/js/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

    <link rel="stylesheet" type="text/css" href="/assets/css/resource.css" />
<link href="../../assets/css/project.css" rel="stylesheet" type="text/css">

    <title>Project 4: A Scheme Interpreter | CS 61A Summer 2015</title>

  </head>

  <body id="index" class="home">
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-section">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="/">CS 61A</a>
        </div>

        <div class="collapse navbar-collapse" id="navbar-collapse-section">
          <ul class="nav navbar-nav navbar-right">
            <li><a href="/">Calendar</a></li>
            <li><a href="/office-hours.html">Office Hours</a></li>
            <li><a href="/tutoring.html">Tutoring</a></li>

            <li><a href="/articles/using-ok.html">Using OK</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Course Info <span class="caret"></span></a>
              <ul class="dropdown-menu">
                <li><a href="/articles/about.html">Syllabus</a></li>
                <li><a href="/staff.html">Staff</a></li>
                <li><a href="/weekly.html">Weekly Schedule</a></li>
              </ul>
            </li>

          </ul>
        </div>
      </div>
    </nav>

    <div id="content" class="container">
      <div class='row'>
  <div class='col-md-9'>
    <div class='page-header'>
      <h1><span class="content-title-brand">Project 4</span>: A Scheme Interpreter</h1>
    </div>

    <div id="haiku">
  
<blockquote><p><img class="img-responsive center-block" src="images/money_tree.png" alt="Money Tree"></p>

<cite>
  Eval calls apply,<br />
  which just calls eval again!<br />
  When does it all end?
</cite></blockquote>

</div>

    <h2>Introduction</h2>


<p>In this project, you will develop an interpreter for a subset of the Scheme
language. As you proceed, think about the issues that arise in the design of a
programming language; many quirks of languages are byproducts of implementation
decisions in interpreters and compilers. The subset of the language used in
this project is described in the <a href="http://composingprograms.com/pages/32-functional-programming.html">functional programming</a> section of
Composing Programs.</p>

<p>You will also implement some small programs in Scheme. Scheme is a simple but
powerful functional language. You should find that much of what you have
learned about Python transfers cleanly to Scheme as well as to other
programming languages. To learn more about Scheme, you can read <a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start">Structure and
Interpretation of Computer Programs</a> online for free. Examples from
Chapters 1 and 2 are included as test cases for this project. Language features
from Chapters 3, 4, and 5 are not part of this project, but of course you are
welcome to extend your interpreter to implement more of the language. Since we
only include a subset of the language, your interpreter will not exactly match
the behavior of other interpreters such as <a href="http://inst.eecs.berkeley.edu/~scheme">STk</a>.</p>

<p>The project concludes with an open-ended graphics contest that challenges you
to produce recursive images in only a few lines of Scheme. As an example, the
picture above abstractly depicts all the ways of making change for $0.50 using
U.S. currency. All flowers appear at the end of a branch with length 50. Small
angles in a branch indicate an additional coin, while large angles indicate a
new currency denomination. In the contest, you too will have the chance to
unleash your inner recursive artist.</p>

<p>This project includes several files, but all of your changes will be made to
the first four: <code>scheme.py</code>, <code>scheme_reader.py</code>, <code>questions.scm</code>, and
<code>tests.scm</code>. You can download all of the project code as a <a href="scheme.zip">zip
archive</a>, which contains the following files:</p>

<ul>
  <li><code>scheme.py</code>: the Scheme evaluator</li>
  <li><code>scheme_reader.py</code>: the Scheme syntactic analyzer</li>
  <li><code>questions.scm</code>: a collection of functions written in Scheme</li>
  <li><code>tests.scm</code>: a collection of test cases written in Scheme</li>
  <li><code>scheme_tokens.py</code>: a tokenizer for Scheme</li>
  <li><code>scheme_primitives.py</code> primitive Scheme procedures</li>
  <li><code>buffer.py</code>: a buffer implementation</li>
  <li><code>ucb.py</code>: utility functions for 61A</li>
  <li><code>ok</code>: the autograder</li>
  <li><code>tests</code>: a directory of tests used by <code>ok</code></li>
</ul>

<p>You'll work in a team of two people, Partner A and Partner B. In each part, you
will do some of the work separately and some together with your partner. For
example, if a problem is marked 5A, then it is a solo problem for Partner A.
Both partners should read, think about, and understand the solution to all
questions. Feel free to help each other on the solo questions. If you choose to
work on the whole project alone, you must complete all questions yourself.</p>

<p>In Parts I and II, you will develop the interpreter in several stages:</p>

<ul>
  <li>Reading Scheme expressions</li>
  <li>Symbol evaluation</li>
  <li>Calling built-in procedures</li>
  <li>Definitions</li>
  <li>Lambda expressions and procedure definition</li>
  <li>Calling user-defined procedures</li>
  <li>Evaluation of special forms</li>
</ul>

<p>In Part III, you will implement Scheme procedures.</p>



<h2>Logistics</h2>

<p>This is a 11-day project. You may work with one other
partner.  You should not share your code with students who are not your
partner or copy from anyone else's solutions.</p>

<p>In the end, you will submit one project for both partners. The
project is worth 28 points. 26 points are
assigned for correctness, and 2 points for the overall <a
  href="../../articles/composition.html">composition</a> of your program.</p>

<p>You will turn in the following files:</p>


<ul>
  <li><code>scheme_reader.py</code></li>
  <li><code>scheme.py</code></li>
  <li><code>questions.scm</code></li>
  <li><code>tests.scm</code></li>
</ul>


<p>You do not need to modify or turn in any other files to complete the
project. To submit the project, run the following command:

<pre><code>python3 ok --submit</code></pre>

<p>You will be able to view your submissions on the <a
  href="http://ok.cs61a.org">OK dashboard</a>.</p>

<p>For the functions that we ask you to complete, there may be some
initial code that we provide. If you would rather not use that code,
feel free to delete it and start from scratch. You may also add new
function definitions as you see fit.</p>

<p>However, please do <b>not</b> modify any other functions.  Doing so may
result in your code failing our autograder tests. Also, please do not
change any function signatures (names, argument order, or number of
arguments).</p>

<h2>Testing</h2>

<p>Throughout this project, you should be testing the correctness of your
code.  It is good practice to test often, so that it is easy to isolate
any problems.</p>

<p>We have provided an <b>autograder</b> called <code>ok</code> to help you with
testing your code and tracking your progress. The first time you run
the autograder, you will be asked to <b>log in with your OK account using your web browser</b>. Please do so. Each time you run
<code>ok</code>, it will back up your work and progress on our
servers.</p>

<p>The primary purpose of <code>ok</code> is to test your implementations, but there
is a catch. At first, the test cases are <i>locked</i>. To unlock tests,
run the following command from your terminal:</p>

<pre><code>python3 ok -u</code></pre>

<p>This command will start an interactive prompt that looks like:</p>

<pre>
=====================================================================
Assignment: A Scheme Interpreter
OK, version ...
=====================================================================

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Unlocking tests

At each "? ", type what you would expect the output to be.
Type exit() to quit

---------------------------------------------------------------------
Question 0 &gt; Suite 1 &gt; Case 1
(cases remaining: 1)

&gt;&gt;&gt; Code here
?
</pre>

<p>At the <code>?</code>, you can type what you expect the output to be.
If you are correct, then this test case will be available the next time
you run the autograder.</p>

<p>The idea is to understand <i>conceptually</i> what your program should do
first, before you start writing any code.</p>

<p>Once you have unlocked some tests and written some code, you can check
the correctness of your program using the tests that you have
unlocked:</p>

<pre>python3 ok</pre>

<p>Most of the time, you will want to focus on a particular question.
Use the <code>-q</code> option as directed in the problems below.</p>

<p>The <code>tests</code> folder is used to store autograder tests, so make sure
<b>not to modify it</b>. You may lose all your unlocking progress if you
do. If you need to get a fresh copy, you can download the
<a href="scheme.zip">zip archive</a> and copy it over, but you
will need to start unlocking from scratch.</p>




<h2 id="details-of-scheme">Details of Scheme</h2>


<p><strong>Read-Eval-Print.</strong> The interpreter reads Scheme expressions, evaluates them,
and displays the results.</p>

<pre><code>scm&gt; 2
2
scm&gt; (+ 2 3)
5
scm&gt; (((lambda (f) (lambda (x) (f f x)))
       (lambda (f k) (if (zero? k) 1 (* k (f f (&#x2d; k 1)))))) 5)
120</code></pre>

<p>The starter code for your Scheme interpreter in <code>scheme.py</code> can successfully
evaluate the first expression above, since it consists of a single number. The
second (a primitive call) and the third (a computation of 5 factorial) will not
work just yet.</p>

<p><strong>Load.</strong> Our <code>load</code> procedure differs from standard Scheme in that we use a
symbol for the file name. For example, to load <code>tests.scm</code>, evaluate the
following call expression.</p>

<pre><code>scm&gt; (load &#x27;tests)</code></pre>

<p><strong>Symbols.</strong> Unlike some implementations of Scheme, in this project numbers and
boolean values cannot be used as symbols.  Also, symbols are always lowercased.
This is illustrated in the following example, which won't work until a little
bit later:</p>

<pre><code>scm&gt; (define 2 3)
Traceback (most recent call last):
  0 (#define 2 3)
Error: bad argument to define
scm&gt; &#x27;Hello
hello</code></pre>

<p><strong>Turtle Graphics.</strong> In addition to standard Scheme procedures, we include
procedure calls to the Python <code>turtle</code> package. This will come in handy in Part
IV, for the contest.</p>

<p>You can read the <a href="http://docs.python.org/py3k/library/turtle.html">turtle module
documentation</a> online.</p>

<p><em>Note</em>: The <code>turtle</code> Python module may not be installed by default on your
personal computer. However, the <code>turtle</code> module is installed on the
instructional machines.  So, if you wish to create turtle graphics for this
project (i.e. for the contest), then you'll either need to setup <code>turtle</code> on
your personal computer or use university computers.</p>


<h3 id="development">Development</h3>


<p><strong>Testing.</strong> The <code>tests.scm</code> file contains a long list of example Scheme
expressions and their expected values.</p>

<pre><code>(+ 1 2)
; expect 3
(/ 1 0)
; expect Error</code></pre>

<p>You can compare the output of your interpreter to the expected output by
running:</p>

<pre><code>python3 ok &#x2d;q tests.scm</code></pre>

<p>For the example above, your scheme interpreter will evaluate <code>(+ 1 2)</code> using
your code in <code>scheme.py</code>, then output a test failure if <code>3</code> is not returned as
the value.  The second example tests for an error (but not the specific error
message.</p>

<p>Only a small subset of tests are designated to run by default because
<code>tests.scm</code> contains an <code>(exit)</code> call near the beginning, which halts testing.
<strong>As you complete more of the project, you should move or remove this call</strong>.</p>

<p><em>Note</em>: your interpreter doesn't know how to <code>exit</code> until Problems 3 and 4 are
completed; all tests will run until then.</p>

<p><strong>Important</strong>: As you proceed in the project, add new tests to the top of
<code>tests.scm</code> to verify the behavior of your implementation. Your composition
score for this project will depend on whether or not you have tested your
implementation in ways that are different from the <code>ok</code> tests.</p>

<p><strong>Exceptions.</strong> As you develop your Scheme interpreter, you may find that Python
raises various uncaught exceptions when evaluating Scheme expressions. As a
result, your Scheme interpreter will halt. Some of these may be the results of
bugs in your program, and some may be useful indications of errors in user
programs. The former should be fixed (of course!) and the latter should be
handled, usually by raising a <code>SchemeError</code>. All <code>SchemeError</code> exceptions are
handled and printed as error messages by the <code>read_eval_print_loop</code> function in
<code>scheme.py</code>. Ideally, there should never be unhandled Python exceptions for any
input to your interpreter.</p>


<h3 id="running-your-scheme-interpreter">Running Your Scheme Interpreter</h3>


<p>To run your Scheme interpreter in an interactive session, type:</p>

<pre><code>python3 scheme.py</code></pre>

<p>You can use your Scheme interpreter to evaluate the expressions in an input file
by passing the file name as a command-line argument to <code>scheme.py</code>:</p>

<pre><code>python3 scheme.py tests.scm</code></pre>

<p>Currently, your Scheme interpreter can handle a few simple expressions, such as:</p>

<pre><code>scm&gt; 1
1
scm&gt; 42
42
scm&gt; true
True</code></pre>

<p>To exit the Scheme interpreter, press <code>Ctrl&#x2d;d</code> or evaluate the <code>exit</code> procedure
(after completing problems 3 and 4):</p>

<pre><code>scm&gt; (exit)</code></pre>


<h2 id="part-i-the-reader">Part I: The Reader</h2>


<blockquote><p>The first part of this project deals with reading and parsing user input. All
changes in this part should be made in <code>scheme_reader.py</code>.</p></blockquote>

<p>The function <code>scheme_read</code> in <code>scheme_reader.py</code> parses a <code>Buffer</code> (see
<code>buffer.py</code>) instance that returns valid Scheme tokens when its <code>current</code> and
<code>pop</code> methods are invoked. This function returns the next full Scheme
expression in the <code>src</code> buffer, using this representation:</p>

<table align="center" class="table table-bordered table-striped">
  <tr>
    <th>Scheme Data Type</th>
    <th>Our Internal Representation</th>
  </tr>

  <tr>
    <td>Numbers</td>
    <td>Python's built-in <code>int</code> and <code>float</code> data
    types.</td>
  </tr>

  <tr>
    <td>Symbols</td>
    <td>Python's built-in <code>string</code> data type.</td>
  </tr>

  <tr>
     <td>Booleans (<code>#t</code>, <code>#f</code>)</td>
     <td>Python's built-in <code>True</code>, <code>False</code> values.</td>
  </tr>

  <tr>
     <td>Pairs</td>
     <td>The <code>Pair</code> class, defined in
     <code>scheme_reader.py</code>.</td>
  </tr>

  <tr>
     <td><code>nil</code></td>
     <td>The <code>nil</code> object, defined in
     <code>scheme_reader.py</code>.</td>
  </tr>
</table>

<br>


<h3 id="problem-1-1-pt">Problem 1 (1 pt)</h3>

<p>Complete the <code>scheme_read</code> function in <code>scheme_reader.py</code> by adding support for
quotation. This function selects behavior based on the type of the next token:</p>

<ul>
  <li>If the next token in <code>src</code> is the string <code>&quot;nil&quot;</code>, return the <code>nil</code> object.
  <strong>(provided)</strong></li>
  <li>If the next token is not a delimiter, then it is self-evaluating. Return it.
  <strong>(provided)</strong></li>
  <li>If the current token is a single quote (such as the first character of
  <code>&#x27;bagel</code>), then return a quote special form (such as <code>(quote bagel)</code>). <strong>(you'll implement this)</strong></li>
  <li>If the current token is a left parenthesis <code>&quot;(&quot;</code>, return the result of
  <code>read_tail</code>. <strong>(provided)</strong></li>
</ul>

<p>Some examples of how to handle the quote form:</p>

<ul>
  <li><code>(quote bagel)</code> is converted to <code>Pair(&#x27;quote&#x27;, Pair(&#x27;bagel&#x27;, nil))</code></li>
  <li><code>&#x27;bagel</code> is equivalent to <code>(quote bagel)</code>, so it is also converted to
  <code>Pair(&#x27;quote&#x27;, Pair(&#x27;bagel&#x27;, nil))</code></li>
</ul>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok &#x2d;q 01 &#x2d;u
python3 ok &#x2d;q 01</code></pre>


<h3 id="problem-2-2-pt">Problem 2 (2 pt)</h3>

<p>Complete the <code>read_tail</code> function in <code>scheme_reader.py</code> by adding support for
dotted lists. A dotted list in Scheme is not necessarily a well-formed list, but
instead has an arbitrary <code>second</code> attribute that may be any Scheme value:</p>

<blockquote><p><code>(1 2 . 3)</code> should be converted to <code>Pair(1, Pair(2, 3))</code></p></blockquote>

<p>The <code>read_tail</code> function expects to read the rest of a list or dotted list,
assuming the open parenthesis of that list has already been popped by
<code>scheme_read</code>.</p>

<p>Consider the case of calling <code>scheme_read</code> on input "<code>(1 2 . 3)</code>". The
<code>read_tail</code> function will be called on the suffix "<code>1 2 . 3)</code>", which is</p>

<ul>
  <li>The pair consisting of the Scheme value <code>1</code> and the value of the tail "<code>2 .
  3)</code>", which is</li>
  <li>The pair consisting of the Scheme value <code>2</code> and the Scheme value <code>3</code>.</li>
</ul>

<p>Thus, <code>read_tail</code> would return <code>Pair(1, Pair(2, 3))</code>.</p>

<blockquote><p><em>Hint</em>: In order to verify that only one element follows a dot, after
encountering a <code>&#x27;.&#x27;</code>, read one additional expression and then
check to see that a closing parenthesis follows.</p></blockquote>

<p>To complete this question, you will need to interact with the parameter <code>src</code>,
which is a <code>Buffer</code> object (defined in <code>buffer.py</code>). There are two main ways to
interact with <code>src</code>:</p>

<ul>
  <li><p><code>src.pop()</code>: returns the <strong>first</strong> token in <code>src</code> and also removes the token
  from <code>src</code>.</p>

  <p>For example, if <code>src</code> currently contains the tokens <code>[4, &#x27;.&#x27;,  3, &#x27;)&#x27;]</code>, then
  <code>src.pop()</code> will return <code>4</code>, and <code>src</code> will be left with <code>[&#x27;.&#x27;, 3, &#x27;)&#x27;]</code>.</p></li>
  <li><p><code>src.current()</code>: returns the <strong>first</strong> token in <code>src</code>, but does not remove
  the token from <code>src</code>.</p>

  <p>For example, if <code>src</code> currently contains the tokens <code>[4, &#x27;.&#x27;,  3, &#x27;)&#x27;]</code>, then
  <code>src.current()</code> will return <code>4</code>; <code>src</code> remains the same.</p></li>
</ul>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok &#x2d;q 02 &#x2d;u
python3 ok &#x2d;q 02</code></pre>

<p>You should also test your parser in the following way:</p>

<ul>
  <li>run the doctests for scheme_reader.py (<code>python3 &#x2d;m doctest scheme_reader.py</code>)</li>
  <li><p>test interactively by running <code>python3 scheme_reader.py</code>. Every time you type
  in a value into the prompt, both the <code>str</code> and <code>repr</code> values of the parsed
  expression are printed.  You can try the following inputs:</p>

<pre><code>read&gt; 42
str : 42
repr: 42
read&gt; &#x27;(1 2 3)
str : (quote (1 2 3))
repr: Pair(&#x27;quote&#x27;, Pair(Pair(1, Pair(2, Pair(3, nil))), nil))
read&gt; nil
str : ()
repr: nil
read&gt; &#x27;()
str : (quote ())
repr: Pair(&#x27;quote&#x27;, Pair(nil, nil))
read&gt; (1 (2 3) (4 (5)))
str : (1 (2 3) (4 (5)))
repr: Pair(1, Pair(Pair(2, Pair(3, nil)), Pair(Pair(4, Pair(Pair(5, nil), nil)), nil)))
read&gt; (1 (9 8) . 7)
str : (1 (9 8) . 7)
repr: Pair(1, Pair(Pair(9, Pair(8, nil)), 7))
read&gt; (hi there . (cs . (student)))
str : (hi there cs student)
repr: Pair(&#x27;hi&#x27;, Pair(&#x27;there&#x27;, Pair(&#x27;cs&#x27;, Pair(&#x27;student&#x27;, nil))))</code></pre></li>
</ul>


<h2 id="part-ii-the-evaluator">Part II: The Evaluator</h2>


<blockquote><p>All changes in this part should be made in <code>scheme.py</code> For each question,
also add a few tests to the top of <code>tests.scm</code> to verify the behavior of your
implementation.</p></blockquote>

<p>In the implementation given to you, the evaluator can only evaluate
self-evaluating expressions: numbers, booleans, and
<code>nil</code>.</p>

<p>Read the first two sections of scheme.py, called Eval/Apply and Environments.</p>

<ul>
  <li>The <code>scheme_eval</code> and <code>scheme_apply</code> functions are complete, but most of the
  functions or methods they use are not yet implemented.</li>
  <li>The <code>apply_primitive</code> and <code>make_call_frame</code> functions assist in applying built-in
  and user-define procedures, respectively.</li>
  <li>The Frame class implements an environment frame.</li>
  <li>The LambdaProcedure class represents user-defined procedures.</li>
</ul>

<p>These are all of the essential components of the interpreter; the rest of scheme.py defines special forms and input/output behavior.</p>

<p>Test your understanding of how these components fit together by unlocking the
tests for <code>eval_apply</code>.</p>

<pre><code>python3 ok &#x2d;q eval_apply &#x2d;u</code></pre>


<h3 id="some-core-functionality">Some Core Functionality</h3>



<h4 id="problem-3-1-pt">Problem 3 (1 pt)</h4>

<p>Implement the <code>lookup</code> method of the <code>Frame</code> class. It takes a symbol (Python
string) and returns the value bound to that name in the first <code>Frame</code> of the
environment in which that name is found.  A <code>Frame</code> represents an environment
via two instance attributes:</p>

<ul>
  <li><code>bindings</code> is a dictionary that maps Scheme symbol keys (represented as
  Python strings) to Scheme values.</li>
  <li><code>parent</code> is the parent <code>Frame</code> instance. The parent of the Global Frame is
  <code>None</code>.</li>
</ul>

<p>Your <code>lookup</code> implementation should:</p>

<ul>
  <li>Return the value of the symbol in <code>self.bindings</code> if it exists.</li>
  <li>Otherwise, <code>lookup</code> that symbol in the <code>parent</code> if the <code>parent</code> exists.</li>
  <li>Otherwise, raise a <code>SchemeError</code>. <strong>(provided)</strong></li>
</ul>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok &#x2d;q 03 &#x2d;u
python3 ok &#x2d;q 03</code></pre>

<p>After you complete this problem, you can open your Scheme interpreter (with <code>python3 scheme.py</code>). You should be able to lookup up built-in procedure names:</p>

<pre><code>scm&gt; +
#[+]
scm&gt; odd?
#[odd?]
scm&gt; display
#[display]</code></pre>

<p>However, your Scheme interpreter will still not be able to apply these
procedures. Let's fix that.</p>


<h4 id="problem-4-2-pt">Problem 4 (2 pt)</h4>

<p>Implement <code>apply_primitive</code>, which is called by <code>scheme_apply</code>. Primitive
procedures are applied by calling a corresponding Python function that
implements the procedure.</p>

<p>Scheme primitive procedures are represented as instances of the
<code>PrimitiveProcedure</code> class, defined in <code>scheme_primitives.py</code>. A
<code>PrimitiveProcedure</code> has two instance attributes:</p>

<ul>
  <li><code>fn</code> is the <strong>Python</strong> function that implements the primitive Scheme
  procedure.</li>
  <li><code>use_env</code> is a boolean flag that indicates whether or not this primitive
  procedure will expect the current environment to be passed in as the last
  argument. The environment is required, for instance, to implement the primitive
  <code>eval</code> procedure.</li>
</ul>

<p>To see a list of all Scheme primitive procedures used in the project, look in
the <code>scheme_primitives.py</code> file. Any function decorated with <code>@primitive</code> will
be added to the globally-defined <code>_PRIMITIVES</code> list.</p>

<p>The <code>apply_primitive</code> function takes a <code>PrimitiveProcedure</code> instance, a Scheme
list of argument values, and the current environment.  Your implementation
should:</p>

<ul>
  <li>Convert the Scheme list to a Python list of arguments. <strong>(provided)</strong></li>
  <li>If the <code>procedure.use_env</code> is <code>True</code>, then add the current environment <code>env</code>
  as the last argument to this Python list.</li>
  <li>Call <code>procedure.fn</code> on all of those arguments (<em>Hint</em>: use <code>*args</code> notation).</li>
  <li>If calling the function results in a <code>TypeError</code> exception being thrown, then
  handle it and raise a <code>SchemeError</code> in the <code>except</code> clause (<code>raise
  SchemeError</code>).</li>
</ul>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok &#x2d;q 04 &#x2d;u
python3 ok &#x2d;q 04</code></pre>

<p>Your interpreter should now be able to evaluate primitive procedure calls,
giving you the functionality of the Calculator language and more.</p>

<pre><code>scm&gt; (+ 1 2)
3
scm&gt; (* 3 4 (&#x2d; 5 2) 1)
36
scm&gt; (odd? 31)
True</code></pre>


<h4 id="problem-5a-1-pt">Problem 5A (1 pt)</h4>

<p>There are two missing parts in the <code>do_define_form</code> function, which handles the
<code>(define ...)</code> special forms.  Implement <strong>just the first part</strong>, which binds
names to values but does not create new procedures.  <code>do_define_form</code> should
return the name after performing the binding.</p>

<pre><code>scm&gt; (define tau (* 2 3.1415926))
tau</code></pre>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok &#x2d;q 05A &#x2d;u
python3 ok &#x2d;q 05A</code></pre>

<p>You should now be able to give names to values and evaluate the resulting
symbols.</p>

<pre><code>scm&gt; (define x 15)
x
scm&gt; (define y (* 2 x))
y
scm&gt; y
30
scm&gt; (+ y (* y 2) 1)
91
scm&gt; (define x 20)
x
scm&gt; x
20
scm&gt; (eval (define tau 6.28))
6.28</code></pre>


<h4 id="problem-6b-1-pt">Problem 6B (1 pt)</h4>

<p>Implement the <code>do_quote_form</code> function, which evaluates the <code>quote</code> special
form.</p>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok &#x2d;q 06B &#x2d;u
python3 ok &#x2d;q 06B</code></pre>

<p>You should now be able to evaluate quoted expressions.</p>

<pre><code>scm&gt; &#x27;hello
hello
scm&gt; &#x27;(1 . 2)
(1 . 2)
scm&gt; &#x27;(1 (2 three . (4 . 5)))
(1 (2 three 4 . 5))
scm&gt; (car &#x27;(a b))
a
scm&gt; (eval (cons &#x27;car &#x27;(&#x27;(1 2))))
1</code></pre>

<p>At this point in the project, your Scheme interpreter should support the
following features:</p>

<ul>
  <li>Evaluate atoms, which include numbers, booleans, nil, and symbols,</li>
  <li>Evaluate the <code>quote</code> special form,</li>
  <li>Evaluate lists,</li>
  <li>Define symbols, and</li>
  <li>Call primitive procedures, for example evaluating <code>(+ (&#x2d; 4 2) 5)</code>.</li>
</ul>


<h3 id="user-defined-procedures">User-Defined Procedures</h3>


<p>User-defined procedures are represented as instances of the <code>LambdaProcedure</code>
class. A <code>LambdaProcedure</code> instance has three instance attributes:</p>

<ul>
  <li><code>formals</code> is a Scheme list of the formal parameters (symbols) that name the
  arguments of the procedure.</li>
  <li><code>body</code> is a single Scheme expression; the body of the procedure.</li>
  <li><code>env</code> is the environment in which the procedure was <strong>defined</strong>.</li>
</ul>


<h4 id="problem-7-2-pt">Problem 7 (2 pt)</h4>

<p>Implement the <code>eval_all</code> function (that is called from <code>do_begin_form</code>), which
will complete the implementation of the <code>begin</code> special form. A <code>begin</code>
expression is evaluated by evaluating all sub-expressions in order. The value
of the <code>begin</code> expression is the value of the final sub-expression.</p>

<pre><code>scm&gt; (begin (+ 2 3) (+ 5 6))
11
scm&gt; (define x (begin (display 3) (newline) (+ 2 3)))
3
x
scm&gt; (+ x 3)
8
scm&gt; (begin (print 3) &#x27;(+ 2 3))
3
(+ 2 3)</code></pre>

<p>If <code>eval_all</code> is passed an empty list of expressions (<code>nil</code>), then it should
return the special value <code>okay</code>, which represents an undefined Scheme value.</p>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok &#x2d;q 07 &#x2d;u
python3 ok &#x2d;q 07</code></pre>


<h4 id="problem-8-1-pt">Problem 8 (1 pt)</h4>

<p>Implement the <code>do_lambda_form</code> method, which creates <code>LambdaProcedure</code> instances
by evaluating <code>lambda</code> expressions. While you cannot call a user-defined
procedure yet, you can verify that you have created the procedure correctly by
evaluating a lambda expression:</p>

<pre><code>scm&gt; (lambda (x y) (+ x y))
(lambda (x y) (+ x y))</code></pre>

<p>In Scheme, it is legal to place more than one expression in the body of a
procedure (although zero body expressions is disallowed). The <code>body</code> attribute
of a <code>LambdaProcedure</code> instance is a Scheme list of body expressions.</p>

<p>Test your implementation before moving on:</p>

<pre><code>python3 ok &#x2d;q 08</code></pre>


<h4 id="problem-9a-2-pt">Problem 9A (2 pt)</h4>

<p>Currently, your Scheme interpreter is able to bind symbols to user-defined
procedures in the following manner:</p>

<pre><code>scm&gt; (define f (lambda (x) (* x 2)))
f</code></pre>

<p>However, we'd like to be able to use the shorthand form of defining named
procedures:</p>

<pre><code>scm&gt; (define (f x) (* x 2))
f</code></pre>

<p>Modify the <code>do_define_form</code> function so that it correctly handles the shorthand
procedure definition form above. Make sure that it can handle multi-expression
bodies.</p>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok &#x2d;q 09A &#x2d;u
python3 ok &#x2d;q 09A</code></pre>

<p>You should now find that defined procedures evaluate to lambda procedures.</p>

<pre><code>scm&gt; (define (square x) (* x x))
square
scm&gt; square
(lambda (x) (* x x))</code></pre>


<h4 id="problem-10">Problem 10 (2 pt)</h4>

<p>Implement the <code>make_child_frame</code> method of the <code>Frame</code> class, which:</p>

<ul>
  <li>Creates a new <code>Frame</code> instance, the parent of which is <code>self</code>. <strong>(provided)</strong></li>
  <li>If the number of inputted argument values does not match with the number of
  formal parameters, raise a <code>SchemeError</code>.</li>
  <li>Binds formal parameters to their corresponding argument values in the newly
  created frame.</li>
</ul>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok &#x2d;q 10 &#x2d;u
python3 ok &#x2d;q 10</code></pre>


<h4 id="problem-11b-2-pt">Problem 11B (2 pt)</h4>

<p>Implement the <code>check_formals</code> function to raise an error whenever the Scheme
list of formal parameters passed to it is invalid.  Raise a <code>SchemeError</code> if
the list of <code>formals</code> is not a well-formed list of symbols or if any symbol is
repeated.</p>

<p><em>Hint</em>: The <code>scheme_symbolp</code> function in <code>scheme_primitives.py</code> returns whether
a value is a Scheme symbol.</p>

<p>Test your implementation before moving on:</p>

<pre><code>python3 ok &#x2d;q 11B</code></pre>


<h4 id="problem-12-2-pt">Problem 12 (2 pt)</h4>

<p>Implement the <code>make_call_frame</code> function called by <code>scheme_apply</code> (at the end
of the <code>Eval/Apply</code> section). It should create a new <code>Frame</code> instance using the
<code>make_child_frame</code> method of the appropriate parent frame, binding formal
parameters to argument values.</p>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok &#x2d;q 12 &#x2d;u
python3 ok &#x2d;q 12</code></pre>

<p>At this point in the project, your Scheme interpreter should support the
following features:</p>

<ul>
  <li>Create procedures using <code>lambda</code> expressions,</li>
  <li>Define named procedures using <code>define</code> expressions, and</li>
  <li>Call user-defined procedures.</li>
</ul>

<blockquote><p>Now is an excellent time to revisit the tests in <code>tests.scm</code> and ensure that
you pass the tests that involve definition (Sections 1.1.2 and 1.1.4).  <strong>You
should also add additional tests of your own at the top of <code>tests.scm</code> to
verify that your interpreter is behaving as you expect.</strong></p></blockquote>


<h3 id="special-forms">Special Forms</h3>


<p>Logical special forms include <code>if</code>, <code>and</code>, <code>or</code>, and <code>cond</code>. These expressions
are special because not all of their sub-expressions may be evaluated.</p>

<p>In Scheme, only <code>False</code> is a false value. All other values are true values. You
can test whether a value is a true value or a false value using the provided
Python functions <code>scheme_true</code> and <code>scheme_false</code>, defined in
<code>scheme_primitives.py</code>. (Note that Scheme traditionally uses <code>#f</code> to indicate a
false value, which is equivalent to <code>false</code> or <code>False</code>. Similarly, <code>true</code> and
<code>True</code> and <code>#t</code> are all equilvalent.)</p>


<h4 id="problem-13-1-pt">Problem 13 (1 pt)</h4>

<p>Implement <code>do_if_form</code> so that <code>if</code> expressions are evaluated correctly. This
function should evaluate either the second (consequent) or third (alternative)
expression of the <code>if</code> expression, depending on whether the value of the first
(predicate) expression is true.</p>

<pre><code>scm&gt; (if (= 4 2) &#x27;a &#x27;b)
b
scm&gt; (if (= 4 4) (* 1 2) (+ 3 4))
2</code></pre>

<p>It is legal to pass in just two expressions to the <code>if</code> special form. In this
case, you should return the second expression if the first expression evaluates
to a true value. Otherwise, return the special <code>okay</code> value, which represents
an undefined value.</p>

<pre><code>scm&gt; (if (= 4 2) &#x27;a)
okay</code></pre>

<blockquote><p><em>Hint</em>: <code>okay</code> is defined in <code>scheme_primitives.py</code> and imported to
<code>scheme.py</code>, so you can refer to it directly as <code>okay</code> in your Python code.
The value <code>okay</code> evaluates to itself.</p></blockquote>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok &#x2d;q 13 &#x2d;u
python3 ok &#x2d;q 13</code></pre>


<h4 id="problem-14b-2-pt">Problem 14B (2 pt)</h4>

<p>Implement <code>do_and_form</code> and <code>do_or_form</code> so that <code>and</code> and <code>or</code> expressions are
evaluated correctly.</p>

<p>The logical forms <code>and</code> and <code>or</code> are <em>short-circuiting</em>. For <code>and</code>, your
interpreter should evaluate each sub-expression from left to right, and if any
of these evaluates to a false value, then <code>False</code> is returned.  Otherwise,
it should return the value of the last sub-expression. If there are no
sub-expressions in an <code>and</code> expression, it evaluates to <code>True</code>.</p>

<pre><code>scm&gt; (and)
True
scm&gt; (and 4 5 6)  ; all operands are true values
6
scm&gt; (and 4 5 (+ 3 3))
6
scm&gt; (and True False 42 (/ 1 0))  ; short&#x2d;circuiting behavior of and
False</code></pre>

<p>For <code>or</code>, evaluate each sub-expression from left to right. If any
sub-expression evaluates to a true value, return that value. Otherwise, return
<code>False</code>. If there are no sub-expressions in an <code>or</code> expression, it evaluates to
<code>False</code>.</p>

<pre><code>scm&gt; (or)
False
scm&gt; (or 5 2 1)  ; 5 is a true value
5
scm&gt; (or False (&#x2d; 1 1) 1)  ; 0 is a true value in Scheme
0
scm&gt; (or 4 True (/ 1 0))  ; short&#x2d;circuiting behavior of or
4</code></pre>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok &#x2d;q 14B &#x2d;u
python3 ok &#x2d;q 14B</code></pre>


<h4 id="problem-15a-2-pt">Problem 15A (2 pt)</h4>

<p>Implement <code>do_cond_form</code> so that it returns the value of the first result
sub-expression corresponding to a true predicate, or the sub-expression
corresponding to <code>else</code>. Your implementation should match the following
examples and the additional tests in <code>tests.scm</code>.</p>

<pre><code>scm&gt; (cond ((= 4 3) &#x27;nope)
           ((= 4 4) &#x27;hi)
           (else &#x27;wait))
hi
scm&gt; (cond ((= 4 3) &#x27;wat)
           ((= 4 4))
           (else &#x27;hm))
True
scm&gt; (cond ((= 4 4) &#x27;here (+ 40 2))
           (else &#x27;wat 0))
42</code></pre>

<p><em>Hint</em>: For the last example, where the body of a <code>cond</code> case has multiple
expressions, use <code>eval_all</code>.</p>

<p>The value of a <code>cond</code> is undefined if there are no true predicates and no
<code>else</code>. In such a case, <code>do_cond_form</code> should return <code>okay</code>.</p>

<pre><code>scm&gt; (cond (False 1) (False 2))
okay</code></pre>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok &#x2d;q 15A &#x2d;u
python3 ok &#x2d;q 15A</code></pre>


<h4 id="problem-16-2-pt">Problem 16 (2 pt)</h4>

<p>The <code>let</code> special form binds symbols to values locally, giving them their
initial values. For example:</p>

<pre><code>scm&gt; (define x &#x27;hi)
x
scm&gt; (define y &#x27;bye)
y
scm&gt; (let ((x 42)
           (y (* 5 10)))
       (list x y))
(42 50)
scm&gt; (list x y)
(hi bye)</code></pre>

<p>Implement <code>make_let_frame</code>, which returns a child frame of <code>env</code> that binds
the symbol in each element of <code>bindings</code> to the value of the corresponding
expression.</p>

<blockquote><p>You may find the following functions and methods useful:</p>

<ul>
  <li><code>check_form</code>: this function can be used to check the structure of each
  binding.</li>
  <li><code>make_child_frame</code>: this method (which you implemented in <a href="#problem-10">Problem
  10</a>) takes two <code>Pair</code>s of <code>formal</code> paremeters and <code>values</code>,
  and creates a new frame with all the <code>formal</code>s bound to the corresponding
  <code>values</code>.</li>
</ul></blockquote>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok &#x2d;q 16 &#x2d;u
python3 ok &#x2d;q 16</code></pre>


<h4 id="problem-17-2-pt">Problem 17 (2 pt)</h4>

<p>Implement <code>do_mu_form</code> to evaluate the <code>mu</code> special form, a non-standard Scheme
expression type. A <code>mu</code> expression is similar to a <code>lambda</code> expression, but
evaluates to a <code>MuProcedure</code> instance that is <strong>dynamically scoped</strong>. The
<code>MuProcedure</code> class has been provided for you.</p>

<p>Additionally, update <code>make_call_frame</code> so that the call frame used to evaluate
the body of a <code>MuProcedure</code> is dynamically scoped.  Calling a <code>LambdaProcedure</code>
uses lexical scoping: the parent of the new call frame is the environment in
which the procedure was <strong>defined</strong>. Calling a <code>MuProcedure</code> created by a <code>mu</code>
expression uses dynamic scoping:  the parent of the new call frame is the
environment in which the call expression was <strong>evaluated</strong>.  As a result, a
<code>MuProcedure</code> does not need to store an environment as an instance attribute.
It can refer to names in the environment from which it was called.</p>

<pre><code>scm&gt; (define f (mu (x) (+ x y)))
f
scm&gt; (define g (lambda (x y) (f (+ x x))))
g
scm&gt; (g 3 7)
13</code></pre>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok &#x2d;q 17 &#x2d;u
python3 ok &#x2d;q 17</code></pre>

<p>Congratulations! Your Scheme interpreter implementation is now complete!</p>

<blockquote><p>You should have been adding tests to the top of <code>tests.scm</code> as you did each
problem.  The tests that you have written tests will be evaluated as part of
your composition score for the project.</p>

<p>To run your tests, run the command:</p>

<pre><code>  python3 ok &#x2d;q tests.scm</code></pre>

<p>Make sure to remove all of the <code>(exit)</code> commands, so that all the tests are run!</p></blockquote>


<h2 id="part-iii-write-some-scheme">Part III: Write Some Scheme</h2>


<p>Not only is your Scheme interpreter itself a tree-recursive program, but it is
flexible enough to evaluate <em>other</em> recursive programs. Implement the following
procedures in Scheme in the <code>questions.scm</code> file.</p>

<blockquote><p>All changes in this part should be made in <code>questions.scm</code>.</p></blockquote>


<h3 id="problem-18-1-pt">Problem 18 (1 pt)</h3>

<p>Implement the <code>enumerate</code> procedure, which takes in a list of values and returns
a list of two-element lists, where the first element is the index of the value,
and the second element is the value itself.</p>

<pre><code>scm&gt; (enumerate &#x27;(3 4 5 6))
((0 3) (1 4) (2 5) (3 6))
scm&gt; (enumerate &#x27;())
()</code></pre>

<p>Test your implementation before moving on:</p>

<pre><code>python3 ok &#x2d;q 18</code></pre>


<h3 id="problem-19-2-pt">Problem 19 (2 pt)</h3>

<p>Implement the <code>list&#x2d;change</code> procedure, which lists all of the ways to make change
for a positive integer <code>total</code> amount of money, using a list of currency
denominations, which is sorted in descending order. The resulting list of ways
of making change should also be returned in descending order.</p>

<p>To make change for 10 with the denominations (25, 10, 5, 1), we get the
possibliites:</p>

<pre><code>10
5, 5
5, 1, 1, 1, 1, 1
1, 1, 1, 1, 1, 1, 1, 1, 1, 1</code></pre>

<p>To make change for 5 with the denominations (4, 3, 2, 1), we get the
possibilities:</p>

<pre><code>4, 1
3, 2
3, 1, 1
2, 2, 1
2, 1, 1, 1
1, 1, 1, 1, 1</code></pre>

<p>You may find that implementing a helper function, <code>cons&#x2d;all</code>, will be useful
for this problem.  <code>cons&#x2d;all</code> takes in an element, <code>first</code> and a list of lists,
<code>rests</code>, and adds <code>first</code> to the beginning of each list in <code>rests</code>:</p>

<pre><code>scm&gt; (cons&#x2d;all 1 &#x27;((2 3) (2 4) (3 5)))
((1 2 3) (1 2 4) (1 3 5))</code></pre>

<p>Test your implementation before moving on:</p>

<pre><code>python3 ok &#x2d;q 19</code></pre>


<h3 id="problem-20-0-pt-optional">Problem 20 (0 pt; <em>optional</em>)</h3>

<p>Implement the <code>hax</code> procedure that draws the following recursive illustration
when passed two arguments, a side length <code>d</code> and recursive depth <code>k</code>.  The
example below is drawn from <code>(hax 200 4)</code>.</p>

<p><img class="img-responsive center-block" src="images/hax.png" alt="hax"></p>

<p>To see how this illustration is constructed, consider this annotated version
that gives the relative lengths of lines of the component shapes in the figure.</p>

<p><img class="img-responsive center-block" src="images/h1.png" alt="hax_annotated"></p>


<h2 id="part-iv-extra-credit">Part IV: Extra Credit</h2>


<p>You have the opportunity to earn a total of 5 extra credit points on this
project.</p>


<h3 id="exra-credt-problem-21-1-pt">Exra Credt Problem 21 (1 pt)</h3>

<p>In Scheme, source code is data. Every non-primitive expression is a
list, and we can write procedures that manipulate other programs just as we
write procedures that manipulate lists.</p>

<p>Re-writing programs can be useful: we can write an interpreter that only
handles a small core of the language, and then write a procedure <code>analyze</code> that
converts other special forms into the core language before a program is passed
to the interpreter.</p>

<p>For example, the <code>let</code> special form is equivalent to a call expression that
begins with a <code>lambda</code> expression. Both create a new frame extending the
current environment and evaluate a body within that new environment.</p>

<pre><code>(let ((x 42) (y 16)) (+ x y))
;; Is equivalent to:
((lambda (x y) (+ x y)) 42 16)</code></pre>

<p>We can use this rule to rewrite all <code>let</code> special forms into <code>lambda</code>
expressions. We prevent evaluation of a program by quoting it, and then pass it
to <code>analyze</code>:</p>

<pre><code>scm&gt; (analyze &#x27;(let ((a 1) (b 2)) (+ a b)))
((lambda (a b) (+ a b)) 1 2)
scm&gt; (analyze &#x27;(let ((a 1)) (let ((b a)) b)))
((lambda (a) ((lambda (b) b) a)) 1)</code></pre>

<p>In order to handle all programs, <code>analyze</code> must be aware of Scheme syntax.
Since Scheme expressions are recursively nested, <code>analyze</code> must also be
recursive. In fact, the structure of <code>analyze</code> looks like that of
<code>scheme_eval</code>:</p>

<pre><code>(define (analyze expr)
  (cond ((atom?   expr) &lt;Analyze atom&gt;)
        ((quoted? expr) &lt;Analyze quoted&gt;)
        ((lambda? expr) &lt;Analyze lambda&gt;)
        ((define? expr) &lt;Analyze define&gt;)
        ((let?    expr) &lt;Analyze let&gt;)
        (else           &lt;Analyze other&gt;)))</code></pre>

<p>Implement the <code>analyze</code> procedure, which takes in an expression and converts
all of the <code>let</code> special forms in the expression into their equivalent <code>lambda</code>
expressions.</p>

<p><em>Hint</em>: You may want to implement <code>apply&#x2d;to&#x2d;all</code> and <code>zip</code> at the top of <code>questions.scm</code>.</p>

<pre><code>scm&gt; (zip &#x27;((1 2) (3 4) (5 6)))
((1 3 5) (2 4 6))
scm&gt; (zip &#x27;((1 2)))
((1) (2))
scm&gt; (zip &#x27;())
(() ())</code></pre>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok &#x2d;q 21 &#x2d;u
python3 ok &#x2d;q 21</code></pre>

<p><em>Note</em>: We used <code>let</code> while defining <code>analyze</code>. What if we want to run
<code>analyze</code> on an interpreter that does not recognize <code>let</code>? We can pass
<code>analyze</code> to itself to <em>compile</em> itself into an equivalent program that does
not use <code>let</code>:</p>

<pre><code>;; The analyze procedure
(define (analyze expr)
  ...)

;; A list representing the analyze procedure
(define analyze&#x2d;code
  &#x27;(define (analyze expr)
     ...))

;; An analyze procedure that does not use &#x27;let&#x27;
(define analyze&#x2d;without&#x2d;let
  (analyze analyze&#x2d;code))</code></pre>


<h3 id="extra-credit-problem-22-2-pt">Extra Credit Problem 22 (2 pt)</h3>

<p>Complete the function <code>scheme_optimized_eval</code> in <code>scheme.py</code>. This alternative
to <code>scheme_eval</code> is properly tail recursive. That is, the interpreter will
allow an unbounded number of active <a href="(http://en.wikipedia.org/wiki/Tail_call)">tail calls</a> in constant space.</p>

<p>The <code>Evaluate</code> class represents an expression that needs to be evaluated in an
environment. When <code>scheme_optimized_eval</code> receives an expression in a <code>tail</code>
context, then it returns an <code>Evaluate</code> instance. Otherwise, it repeatedly
evaluates expressions within the body of a <code>while</code> statement, updating <code>result</code>
in each iteration.</p>

<p>A successful implementation will require changes to several other functions.
All tail calls should call <code>scheme_eval</code> with <code>True</code> as a third argument,
indicating a tail call.</p>

<p>Once you finish, uncomment the following line in <code>scheme.py</code> to use your
implementation:</p>

<pre><code>scheme_eval = scheme_optimized_eval</code></pre>

<p>Test your understanding and implementation before moving on:</p>

<pre><code>python3 ok &#x2d;q EC &#x2d;u
python3 ok &#x2d;q EC</code></pre>


<h3 id="extra-credit-problem-23-2-pt">Extra Credit Problem 23 (2 pt)</h3>


<p>In this section, we will add support for streams.</p>

<blockquote><p>You will be writing all the code for this portion from scratch; there is no
skeleton provided. This gives you some practice on adding a brand new
feature to a project!</p></blockquote>

<p>Recall that a <strong>stream</strong> is a <code>Pair</code> whose second argument is lazily evaluated;
we evaluated the rest of a stream on demand:</p>

<pre><code>scm&gt; (define s (cons&#x2d;stream 1 (cons&#x2d;stream 2 nil)))
s
scm&gt; s
(1 . #[promise (not forced)])
scm&gt; (stream&#x2d;cdr s)
(2 . #[promise (not forced)])
scm&gt; s
(1 . #[promise (forced)])</code></pre>

<p>Notice that the "rest" of the stream <code>s</code> is a <strong>promise</strong>; the promise will
only evaluate when we force it to. You can create promises with the <code>delay</code>
special form:</p>

<pre><code>scm&gt; (define x (delay (+ 3 4)))
x
scm&gt; x
#[promise (not forced)]
scm&gt; (force x)
7
scm&gt; x
#[promise (forced)]</code></pre>

<p>Why is <code>delay</code> a special form? We can't evaluate its "operand" right away (in
this case, <code>(+ 3 4)</code>). Instead, we want to encapsulate <code>(+ 3 4)</code> in a <code>Promise</code>
object. We only evaluate <code>(+ 3 4)</code> when we call the <code>force</code> procedure on the
<code>Promise</code>.</p>

<blockquote><p>We've added some extra primitive procedures and tests for this question.
<strong>If you started the project before 2:00 AM on 8/2</strong>, download and replace
<a href="scheme_primitives.py">scheme_primitives.py</a>, <a href="tests/23.py">tests/23.py</a>, and
<a href="proj4.ok">proj4.ok</a>. <strong>You must replace these three files before you can
test your work.</strong></p></blockquote>

<p>To complete this part, you will need to make the following changes in
<code>scheme.py</code>:</p>

<ul>
  <li><p>Create a class called <code>Promise</code> that behaves in the following way:</p>

<pre><code>&gt;&gt;&gt; expression = Pair(&#x27;+&#x27;, Pair(3, Pair(4, nil)))
&gt;&gt;&gt; env = create_global_frame()
&gt;&gt;&gt; p = Promise(expression, env)
&gt;&gt;&gt; str(p)
&#x27;#[promise (not forced)]&#x27;
&gt;&gt;&gt; p.evaluate()
7
&gt;&gt;&gt; str(p)
&#x27;#[promise (forced)]&#x27;</code></pre>

  <p>What three methods do you need to create in the <code>Promise</code> class to support
  this behavior?</p>

  <p>When you call <code>evaluate</code> on a <code>Promise</code>, you should store the resulting
  valiue. All subsequent calls to <code>evaluate</code> should immediately
  return the stored value; you should not evaluate the expression again:</p>

<pre><code># (print 5) will print 5 to the screen and return okay
&gt;&gt;&gt; expression = Pair(&#x27;print&#x27;, Pair(5, nil))
&gt;&gt;&gt; env = create_global_frame()
&gt;&gt;&gt; p = Promise(expression, env)
&gt;&gt;&gt; value = p.evaluate()
5
&gt;&gt;&gt; value
okay
&gt;&gt;&gt; p.evaluate()  # Should not evaluate expression again
okay</code></pre></li>
  <li><p>Create a function called <code>do_delay_form</code> that handles the <code>delay</code> special
  form. <code>delay</code> simply takes one expression and returns a <code>Promise</code> that
  encapsulates that expression. The code for this function should be simple.</p>

  <p>You will also need to add <code>delay</code> to the dictionary of <code>SPECIAL_FORMS</code>.
  Search your file to see how <code>do_mu_procedure</code> is added to <code>SPECIAL_FORMS</code>;
  use that as an example.</p></li>
  <li><p>Create a function called <code>do_cons_stream_form</code> that handles the <code>cons&#x2d;stream</code>
  special form. <code>cons&#x2d;stream</code> behaves like <code>cons</code> in that it returns a <code>Pair</code>;
  however, its second argument is a <code>Promise</code>, not another <code>Pair</code>:</p>

<pre><code>scm&gt; (cons 1 nil)
(1)
scm&gt; (cons&#x2d;stream 1 nil)
(1 . #[promise (not forced)])</code></pre>

  <p>Again, the code for this function should be simple.</p></li>
</ul>

<p>Overall, the staff solution uses around 25 lines of code (including blank
lines). The implementation of this section is not difficult; most of the work
is understanding the concept of streams and promises. Your code should be
organized roughly as follows:</p>

<pre><code>class Promise:
    ...

def do_delay_form(expressions, env):
    ...

def do_cons_stream_form(expressions, env):
    ...

SPECIAL_FORMS[&#x27;delay&#x27;] = do_delay_form
SPECIAL_FORMS[&#x27;cons&#x2d;stream&#x27;] = do_cons_stream_form</code></pre>


<h3 id="conclusion">Conclusion</h3>


<p><strong>Congratulations!</strong> You have finished the final project for 61A! Assuming your
tests are good and you've passed them all, consider yourself a proper computer
scientist!</p>

<p>Now, get some sleep. You've earned it!</p>


<h2 id="recursive-art-contest">Recursive Art Contest</h2>


<p>We've added a number of primitive drawing procedures that are collectively
called "turtle graphics".  The <em>turtle</em> represents the state of the drawing
module, which has a position, an orientation, a pen state (up or down), and a
pen color. The <code>tscheme__x_</code> functions in <code>scheme_primitives.py</code> are the
implementations of these procedures, and show their parameters with a brief
description of each.</p>

<p>The Python <a href="http://docs.python.org/release/3.2/library/turtle.html">documentation of the turtle
module</a> contains more
detail.</p>

<p><strong>Contest</strong>: Create a visualization of an iterative or recursive process of your
choosing, using turtle graphics. Your implementation must be written entirely in
Scheme using the interpreter you have built. However, you may add primitive
procedures to interface with Python's <code>turtle</code> or <code>math</code> modules. Other than
that <em>all computation must be done in Scheme</em>. If you do add new primitives,
then make sure to submit <code>scheme_primitives.py</code> in addition to <code>contest.scm</code>.</p>

<p>Prizes, as well as <strong>3 extra credit points</strong>, will be awarded for the winning
entry in each of the following categories:</p>

<ul>
  <li><em>Featherweight</em>: Fewer than 256 Scheme tokens</li>
  <li><em>Heavyweight</em>: Fewer than 2048 Scheme tokens</li>
</ul>

<p>You can check the number of tokens in a Scheme file called <code>contest.scm</code> by
running the command</p>

<pre><code>python3 scheme_tokens.py contest.scm</code></pre>

<p>Entries (code and images) will be posted online, and winners will be selected
by popular vote as part of a future homework.  The voting instructions will
read:</p>

<blockquote><p>Please vote for your favorite entry in this semester's 61A Recursion
Exposition contest.  The winner should exemplify the principles of elegance,
beauty, and abstraction that are prized in the Berkeley computer science
curriculum. As an academic community, we should strive to recognize and
reward merit and achievement (translation: please don't just vote for your
friends).</p></blockquote>

<p>To improve your chance of success, you are welcome to include a title and
descriptive <a href="http://en.wikipedia.org/wiki/Haiku">haiku</a> in the comments of your
entry, which will be included in the voting.</p>

<p>Entries that do not construct an image iteratively or recursively may be
disqualified. Please don't just draw a preexisting image, even if the
drawing function is iterative or recursive. If you're unsure, just ask.</p>

<p>Submission instructions will be posted closer to the deadline.</p>


<h3 id="extra-challenge">Extra Challenge</h3>


<p>We have implemented a significant subset of Scheme in this project, but our
interpreter can be extended with more features by following the <a href="extensions.html">extension
instructions</a>.</p>


  </div>

  <div class='col-md-3'>
    <nav class='hidden-print hidden-sm hidden-xs sidebar'>
      <ul>
  <li><a href="#details-of-scheme">Details of Scheme</a></li>
  <ul>
  <li><a href="#development">Development</a></li>
  <li><a href="#running-your-scheme-interpreter">Running Your Scheme Interpreter</a></li>
</ul>

  <li><a href="#part-i-the-reader">Part I: The Reader</a></li>
  <ul>
  <li><a href="#problem-1-1-pt">Problem 1 (1 pt)</a></li>
  <li><a href="#problem-2-2-pt">Problem 2 (2 pt)</a></li>
</ul>

  <li><a href="#part-ii-the-evaluator">Part II: The Evaluator</a></li>
  <ul>
  <li><a href="#some-core-functionality">Some Core Functionality</a></li>
  <ul>
  <li><a href="#problem-3-1-pt">Problem 3 (1 pt)</a></li>
  <li><a href="#problem-4-2-pt">Problem 4 (2 pt)</a></li>
  <li><a href="#problem-5a-1-pt">Problem 5A (1 pt)</a></li>
  <li><a href="#problem-6b-1-pt">Problem 6B (1 pt)</a></li>
</ul>

  <li><a href="#user-defined-procedures">User-Defined Procedures</a></li>
  <ul>
  <li><a href="#problem-7-2-pt">Problem 7 (2 pt)</a></li>
  <li><a href="#problem-8-1-pt">Problem 8 (1 pt)</a></li>
  <li><a href="#problem-9a-2-pt">Problem 9A (2 pt)</a></li>
  <li><a href="#problem-10">Problem 10 (2 pt)</a></li>
  <li><a href="#problem-11b-2-pt">Problem 11B (2 pt)</a></li>
  <li><a href="#problem-12-2-pt">Problem 12 (2 pt)</a></li>
</ul>

  <li><a href="#special-forms">Special Forms</a></li>
  <ul>
  <li><a href="#problem-13-1-pt">Problem 13 (1 pt)</a></li>
  <li><a href="#problem-14b-2-pt">Problem 14B (2 pt)</a></li>
  <li><a href="#problem-15a-2-pt">Problem 15A (2 pt)</a></li>
  <li><a href="#problem-16-2-pt">Problem 16 (2 pt)</a></li>
  <li><a href="#problem-17-2-pt">Problem 17 (2 pt)</a></li>
</ul>

</ul>

  <li><a href="#part-iii-write-some-scheme">Part III: Write Some Scheme</a></li>
  <ul>
  <li><a href="#problem-18-1-pt">Problem 18 (1 pt)</a></li>
  <li><a href="#problem-19-2-pt">Problem 19 (2 pt)</a></li>
  <li><a href="#problem-20-0-pt-optional">Problem 20 (0 pt; <em>optional</em>)</a></li>
</ul>

  <li><a href="#part-iv-extra-credit">Part IV: Extra Credit</a></li>
  <ul>
  <li><a href="#exra-credt-problem-21-1-pt">Exra Credt Problem 21 (1 pt)</a></li>
  <li><a href="#extra-credit-problem-22-2-pt">Extra Credit Problem 22 (2 pt)</a></li>
  <li><a href="#extra-credit-problem-23-2-pt">Extra Credit Problem 23 (2 pt)</a></li>
  <li><a href="#conclusion">Conclusion</a></li>
</ul>

  <li><a href="#recursive-art-contest">Recursive Art Contest</a></li>
  <ul>
  <li><a href="#extra-challenge">Extra Challenge</a></li>
</ul>

</ul>

    </nav>
  </div>

</div>
    </div>
  </body>
  <script>
  $('.sidebar ul').addClass('nav nav-stacked');
  $('body').scrollspy({
    target: '.sidebar',
    offset: 40
  });
</script>

</html>
